use core::marker::PhantomData;
use std::convert::TryInto;
use std::fmt;

use ark_ec::AffineCurve;
//use ark_bls12_381::Fr;
//use ark_ec::ProjectiveCurve;
use ark_ec::twisted_edwards_extended::GroupProjective;
use ark_ec::models::{TEModelParameters as Parameters};
use ark_ed_on_bls12_381::{Fq, EdwardsAffine, Fr};
use ark_ff::{PrimeField, UniformRand};
use ark_sponge::CryptographicSponge;
use ark_sponge::poseidon::{PoseidonSponge, PoseidonSpongeState, PoseidonSpongeMode};
use ark_sponge::SpongeExt;

use ark_std::rand::Error;
use ark_std::test_rng;
use bytemuck;

use ark_ff::{Zero, ToBytes, FromBytes};
use sha3::{Digest, Sha3_256};

// serialize.. for calculation based on bytes
use ark_serialize::{
    buffer_bit_byte_size,
    CanonicalDeserialize, CanonicalDeserializeWithFlags, CanonicalSerialize,
    CanonicalSerializeWithFlags, SWFlags, SerializationError,
};

#[macro_use]
use lazy_static::lazy_static;

use crate::poseidon::{poseidon_parameters_for_test_s, poseidon_parameters_for_encryption};

const MESSAGE_CAPACITY: usize = 2;
const CIPHER_SIZE: usize = MESSAGE_CAPACITY + 1;
const HASH_WIDTH: usize = 5;

lazy_static! {
    static ref CIPHER_BYTES_SIZE: usize = CIPHER_SIZE * Fq::size_in_bits();  // BaseField
}
const b_CIPHER_BYTES_SIZE: usize = CIPHER_SIZE * (381 + 7) / 8;  // BaseField

pub struct PoseidonEncryption{
    //pub cipher_size: usize,
}

//== BlsScalar Info ==//
pub struct BlsScalarInfo {
    pub bls_scalar: Fq, // Scalar field of BLS12_381
    byte_length: usize,
}

impl BlsScalarInfo {
    pub const fn new( bls_scalar: Fq, byte_length: usize) -> Self {
        Self{ bls_scalar, byte_length}
    }
    pub fn to_bytes(&self) -> [u8; b_CIPHER_BYTES_SIZE] {

        let mut buf = Vec::new();
        self.bls_scalar.serialize(&mut buf).unwrap();
//        self.bls_scalar.serialize_uncompressed(buf);

        buf.try_into().unwrap()
    }
}

impl fmt::Debug for BlsScalarInfo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{{blsScalar: {:?}, byteLength: {}}}", self.bls_scalar, self.byte_length)
    }
}

impl PoseidonEncryption
{
    pub const fn new() -> Self {
        Self{
            //cipher_size : CIPHER_SIZE * Fq::size_in_bits(),
        }
    }

    pub const fn capacity() -> usize {
        MESSAGE_CAPACITY
    }

    pub const fn cipher_size() -> usize {
        CIPHER_SIZE
    }

/* 
    This library implements a twisted Edwards curve whose base field is the scalar field of the
     curve BLS12-377. This allows defining cryptographic primitives that use elliptic curves over
     the scalar field of the latter curve. This curve was generated by Sean Bowe, and is also known
     as [Jubjub](https://github.com/zkcrypto/jubjub).

     Curve information:
     * Base field: q = 52435875175126190479447740508185965837690552500527637822603658699938581184513
     * Scalar field: r = 6554484396890773809930967563523245729705921265872317281365359162392183254199
     * Valuation(q - 1, 2) = 32
     * Valuation(r - 1, 2) = 1
     * Curve equation: ax^2 + y^2 =1 + dx^2y^2, where
        * a = -1
        * d = -(10240/10241)
*/    
    fn initial_state(secret: &EdwardsAffine, nonce: &Fq) -> [Fq; HASH_WIDTH]
    {
        //domain - maximum plaintext length of the elements of Fq, as defined in the paper 
        let domain: [u64;4] = [0x100000000u64, 0, 0, 0];
        let domain_u8 : [u8; 4*8] = bytemuck::cast(domain);

        // The size of the message is constant because any absent input is replaced by zero
        let size: [u64; 4] = [MESSAGE_CAPACITY as u64, 0,0,0];
        let size_u8: [u8; 4*8] = bytemuck::cast(size);

        [
            Fq::from_le_bytes_mod_order(&domain_u8),
            Fq::from_le_bytes_mod_order(&size_u8),
            secret.x,
            secret.y,
            *nonce,
        ]
    }

/*
 let mut buf = Vec::new();
 input.serialize(&mut buf).unwrap();
 Some(F2::from_le_bytes_mod_order(&buf))
*/

    fn to_bytes(cipher_text: [Fq; CIPHER_SIZE]) -> [u8; b_CIPHER_BYTES_SIZE] {
        let mut bytes = [0u8; b_CIPHER_BYTES_SIZE];
        cipher_text.iter().enumerate().for_each(|(i,c)| {
            let n = i * Fq::size_in_bits();

            let mut buf = Vec::new();
            c.serialize(&mut buf).unwrap();

            bytes[n..n + Fq::size_in_bits()].copy_from_slice(&buf);
        });
        bytes
    }

    pub fn from_bytes( bytes: &[u8; b_CIPHER_BYTES_SIZE]) -> Result<[Fq; CIPHER_SIZE], Error> {
        let mut cipher: [Fq; CIPHER_SIZE] = [Fq::zero(); CIPHER_SIZE];  // use ark_ff::Zero

        for (i, scalar) in cipher.iter_mut().enumerate() {
            //let idx = i * (buffer_bit_byte_size(Fq::size_in_bits().buffer_size);
            let idx = i * scalar.serialized_size();
            let len = idx + scalar.serialized_size();
            *scalar = Fq::deserialize(&bytes[idx..len]).unwrap();
        }

        Ok(cipher)
    }

    pub fn calcuate_secret_key(y_bytes: &[u8]) -> EdwardsAffine {
        let mut hasher = Sha3_256::new();
        hasher.update(y_bytes);

        let result = hasher.finalize();

        let y_hash = format!("{:x}", result);
        let secret = y_hash.as_bytes();
        let secret = Fq::from_be_bytes_mod_order(&secret);

        EdwardsAffine::prime_subgroup_generator().mul(secret.into_repr()).into()
    }

    pub fn get_message_bls_scalar_vector(&self, message_bytes: &[u8])
        -> [Fq; PoseidonEncryption::capacity()] {

        let mut message_vecs : Vec<Vec<u8>> = message_bytes.to_vec()
                                            .chunks(32)
                                            .map(|s| s.into()).collect();
        let mut bls_scalars = Vec::new();

        for (_, message_vec) in message_vecs.iter_mut().enumerate() {
            let byte_length = message_vec.capacity();
            message_vec.resize(32, 0);

            let temp = &*message_vec;
            let message: [u8; 32] = temp.as_slice()
                                    .try_into().unwrap();
            
            bls_scalars.push(BlsScalarInfo::new(
                Fq::read(message.as_ref()).unwrap(),
                byte_length ));
        }

        let mut messages = [Fq::zero(); PoseidonEncryption::capacity()];
        let mut index = 0;
        for (_, bls_scalar_info) in bls_scalars.iter().enumerate() {
            messages[index] = bls_scalar_info.bls_scalar;
            index += 1;
        }

        messages
    }

    pub fn encrypt_scalar(&self, message: &[Fq], secret: &EdwardsAffine) -> ([Fq; CIPHER_SIZE], Fq) {
        let zero = Fq::zero();
        let nonce = Fq::rand(&mut test_rng());

        let mut cipher_scalar = [zero; CIPHER_SIZE];

        // Strategy : Poseidon
        let mut index : usize = 0;
        let mut internal_state = PoseidonEncryption::initial_state(&secret, &nonce).to_vec();

        //let parameter = poseidon_parameters_for_test_s::<Fq>();
        let parameter = poseidon_parameters_for_encryption::<Fq>();
        /*let mut state = PoseidonSpongeState::<Fq>{
            state: internal_state,
            mode: PoseidonSpongeMode::Absorbing { next_absorb_index: index },
        };*/

        let count = (MESSAGE_CAPACITY + 3) / 4;

        (0..count).for_each(|i| {
            let mut state = PoseidonSpongeState::<Fq>{
                state: internal_state.clone(),
                mode: PoseidonSpongeMode::Absorbing { next_absorb_index: index },
            };
            let mut native_sponge = PoseidonSponge::< >::from_state(state, &parameter);
            native_sponge.permute();

            internal_state = native_sponge.into_state().state;
            (0..4).for_each(|j| {
                if 4 * i + j < MESSAGE_CAPACITY {
                    internal_state[j+1] += if 4 * i + j < message.len() {
                        message[4 * i + j]
                    } else {
                        Fq::zero()
                    };

                    cipher_scalar[4 * i + j] = internal_state[j + i];
                }
            });
            index += 1;
        });

        let mut last_state = PoseidonSpongeState::<Fq>{
            state: internal_state.clone(),
            mode: PoseidonSpongeMode::Absorbing { next_absorb_index: index }
        };
        let mut last_sponge = PoseidonSponge::< >::from_state(last_state, &parameter);
        last_sponge.permute();
        internal_state = last_sponge.into_state().state;

        cipher_scalar[MESSAGE_CAPACITY] = internal_state[1];
        (cipher_scalar, nonce)


        // message to covert into Vec<u8>
        //let mut buf = Vec::new();
        //message.serialize(&mut buf).unwrap();
    }

    pub fn encrypt(&self, message: String, secret: &EdwardsAffine) 
    -> (Vec<String>, Fq, [Fq; PoseidonEncryption::capacity()], [Fq; CIPHER_SIZE]) {

        let message_bls_scalar_vector = self.get_message_bls_scalar_vector(message.as_bytes());
        let (cipher_scalar, nonce) = self.encrypt_scalar(&message_bls_scalar_vector, secret);
    
        let mut cipher_text_hexes = Vec::new();
        let cipher_text_bytes = PoseidonEncryption::to_bytes(cipher_scalar);

        cipher_text_hexes.push(hex::encode(cipher_text_bytes));

        (cipher_text_hexes, nonce, message_bls_scalar_vector, cipher_scalar)
    }

}

#[test]
fn test_module() {
    let nonce = Fq::rand(&mut test_rng());
    println!("{:?}", nonce);

    let enc = PoseidonEncryption::new();
    let encrypted_msg = enc.encrypt("message".to_string(), &PoseidonEncryption::calcuate_secret_key(&[0u8]) );

    println!("{:?}", encrypted_msg);
}